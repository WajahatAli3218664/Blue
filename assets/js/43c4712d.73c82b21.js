"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_textbook=self.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[71],{6791(n,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=t(4848),i=t(8453);const o={},r="Path Planning & Navigation",s={id:"module3/path-planning",title:"Path Planning & Navigation",description:"Introduction",source:"@site/docs/module3/path-planning.md",sourceDirName:"module3",slug:"/module3/path-planning",permalink:"/docs/module3/path-planning",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Isaac ROS Perception",permalink:"/docs/module3/isaac-perception"},next:{title:"Module 4: Vision-Language-Action (VLA)",permalink:"/docs/module4/"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Navigation Stack Setup",id:"navigation-stack-setup",level:2},{value:"Advanced Path Planning",id:"advanced-path-planning",level:2},{value:"Hardware Deployment",id:"hardware-deployment",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"path-planning--navigation",children:"Path Planning & Navigation"}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Advanced path planning and navigation using Isaac ROS and Nav2 integration."}),"\n",(0,a.jsx)(e.h2,{id:"navigation-stack-setup",children:"Navigation Stack Setup"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom nav_msgs.msg import Path, OccupancyGrid\nfrom nav2_simple_commander import BasicNavigator\nimport numpy as np\n\nclass NavigationController(Node):\n    def __init__(self):\n        super().__init__('navigation_controller')\n        \n        # Nav2 Basic Navigator\n        self.navigator = BasicNavigator()\n        \n        # Publishers and Subscribers\n        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.goal_sub = self.create_subscription(PoseStamped, '/goal_pose', self.goal_callback, 10)\n        self.map_sub = self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10)\n        \n        # Navigation state\n        self.current_map = None\n        self.navigation_active = False\n        \n    def goal_callback(self, goal_msg):\n        \"\"\"Handle new navigation goal\"\"\"\n        self.get_logger().info(f'New goal received: {goal_msg.pose.position.x}, {goal_msg.pose.position.y}')\n        \n        # Set goal using Nav2\n        self.navigator.goToPose(goal_msg)\n        self.navigation_active = True\n        \n        # Monitor navigation progress\n        self.create_timer(0.5, self.check_navigation_status)\n    \n    def check_navigation_status(self):\n        \"\"\"Monitor navigation progress\"\"\"\n        if not self.navigation_active:\n            return\n            \n        if self.navigator.isTaskComplete():\n            result = self.navigator.getResult()\n            if result == BasicNavigator.TaskResult.SUCCEEDED:\n                self.get_logger().info('Navigation succeeded!')\n            else:\n                self.get_logger().warn('Navigation failed!')\n            self.navigation_active = False\n    \n    def map_callback(self, map_msg):\n        \"\"\"Update current map for path planning\"\"\"\n        self.current_map = map_msg\n        \n        # Extract occupancy grid data\n        width = map_msg.info.width\n        height = map_msg.info.height\n        resolution = map_msg.info.resolution\n        \n        # Convert to numpy array for processing\n        occupancy_data = np.array(map_msg.data).reshape((height, width))\n        \n        # Identify free space, obstacles, and unknown areas\n        free_space = (occupancy_data == 0)\n        obstacles = (occupancy_data == 100)\n        unknown = (occupancy_data == -1)\n        \n        self.get_logger().info(f'Map updated: {width}x{height}, resolution: {resolution}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    nav_controller = NavigationController()\n    rclpy.spin(nav_controller)\n    nav_controller.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-path-planning",children:"Advanced Path Planning"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import heapq\nimport math\nfrom typing import List, Tuple\n\nclass AStarPlanner:\n    def __init__(self, occupancy_grid, resolution):\n        self.grid = occupancy_grid\n        self.resolution = resolution\n        self.height, self.width = occupancy_grid.shape\n        \n    def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:\n        """Euclidean distance heuristic"""\n        return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)\n    \n    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """Get valid neighboring cells"""\n        neighbors = []\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                    \n                x, y = pos[0] + dx, pos[1] + dy\n                if (0 <= x < self.height and 0 <= y < self.width and \n                    self.grid[x, y] == 0):  # Free space\n                    neighbors.append((x, y))\n        return neighbors\n    \n    def plan_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> List[Tuple[int, int]]:\n        """A* path planning algorithm"""\n        open_set = [(0, start)]\n        came_from = {}\n        g_score = {start: 0}\n        f_score = {start: self.heuristic(start, goal)}\n        \n        while open_set:\n            current = heapq.heappop(open_set)[1]\n            \n            if current == goal:\n                # Reconstruct path\n                path = []\n                while current in came_from:\n                    path.append(current)\n                    current = came_from[current]\n                path.append(start)\n                return path[::-1]\n            \n            for neighbor in self.get_neighbors(current):\n                tentative_g_score = g_score[current] + 1\n                \n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\n                    came_from[neighbor] = current\n                    g_score[neighbor] = tentative_g_score\n                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n        \n        return []  # No path found\n\nclass DynamicWindowApproach:\n    def __init__(self):\n        self.max_speed = 1.0\n        self.max_yaw_rate = 1.0\n        self.max_accel = 0.2\n        self.max_delta_yaw_rate = 0.2\n        self.v_resolution = 0.01\n        self.yaw_rate_resolution = 0.1\n        self.dt = 0.1\n        self.predict_time = 3.0\n        \n    def calc_dynamic_window(self, x, config):\n        """Calculate dynamic window based on current state"""\n        # Current velocity constraints\n        vs = [0, self.max_speed, -self.max_yaw_rate, self.max_yaw_rate]\n        \n        # Dynamic constraints based on acceleration\n        vd = [x[3] - self.max_accel * self.dt,\n              x[3] + self.max_accel * self.dt,\n              x[4] - self.max_delta_yaw_rate * self.dt,\n              x[4] + self.max_delta_yaw_rate * self.dt]\n        \n        # Final dynamic window\n        dw = [max(vs[0], vd[0]), min(vs[1], vd[1]),\n              max(vs[2], vd[2]), min(vs[3], vd[3])]\n        \n        return dw\n    \n    def predict_trajectory(self, x_init, v, y, dt, predict_time):\n        """Predict robot trajectory"""\n        x = np.array(x_init)\n        trajectory = np.array(x)\n        time = 0\n        \n        while time <= predict_time:\n            x = self.motion(x, [v, y], dt)\n            trajectory = np.vstack((trajectory, x))\n            time += dt\n            \n        return trajectory\n    \n    def motion(self, x, u, dt):\n        """Robot motion model"""\n        x[2] += u[1] * dt\n        x[0] += u[0] * math.cos(x[2]) * dt\n        x[1] += u[0] * math.sin(x[2]) * dt\n        x[3] = u[0]\n        x[4] = u[1]\n        \n        return x\n'})}),"\n",(0,a.jsx)(e.h2,{id:"hardware-deployment",children:"Hardware Deployment"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Jetson Orin"}),": Real-time path planning with GPU acceleration"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"RTX Workstations"}),": Complex multi-robot path planning"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Cloud Integration"}),": AWS RoboMaker for fleet management"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>s});var a=t(6540);const i={},o=a.createContext(i);function r(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);