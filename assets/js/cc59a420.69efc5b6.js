"use strict";(self.webpackChunkphysical_ai_humanoid_robotics_textbook=self.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[986],{4118(n,e,i){i.r(e),i.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>_,frontMatter:()=>a,metadata:()=>r,toc:()=>m});var t=i(4848),o=i(8453);const a={},l="Simulated Humanoid",r={id:"module5/simulated-humanoid",title:"Simulated Humanoid",description:"Introduction",source:"@site/docs/module5/simulated-humanoid.md",sourceDirName:"module5",slug:"/module5/simulated-humanoid",permalink:"/docs/module5/simulated-humanoid",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Module 5: Capstone Autonomous Humanoid Project",permalink:"/docs/module5/"},next:{title:"Obstacle Navigation",permalink:"/docs/module5/obstacle-navigation"}},s={},m=[{value:"Introduction",id:"introduction",level:2},{value:"Humanoid URDF Design",id:"humanoid-urdf-design",level:2},{value:"Humanoid Control System",id:"humanoid-control-system",level:2},{value:"Advanced Behaviors",id:"advanced-behaviors",level:2},{value:"Hardware Deployment",id:"hardware-deployment",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"simulated-humanoid",children:"Simulated Humanoid"}),"\n",(0,t.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(e.p,{children:"Build a complete humanoid robot simulation with realistic physics, sensors, and AI integration."}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-urdf-design",children:"Humanoid URDF Design"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="humanoid_robot">\n  \x3c!-- Base/Torso --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.6"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.6"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="20.0"/>\n      <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="0.5"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <link name="head_link">\n    <visual>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.9 0.7 0.6 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  <joint name="neck_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="head_link"/>\n    <origin xyz="0 0 0.35" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0"/>\n  </joint>\n\n  \x3c!-- Arms --\x3e\n  <link name="left_upper_arm">\n    <visual>\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.9 0.7 0.6 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.05" length="0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.02" ixy="0.0" ixz="0.0" iyy="0.02" iyz="0.0" izz="0.005"/>\n    </inertial>\n  </link>\n\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0 0.15 0.2" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-3.14" upper="3.14" effort="50" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Legs --\x3e\n  <link name="left_upper_leg">\n    <visual>\n      <geometry>\n        <cylinder radius="0.08" length="0.4"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 1 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.08" length="0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="5.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.02"/>\n    </inertial>\n  </link>\n\n  <joint name="left_hip_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="left_upper_leg"/>\n    <origin xyz="0 0.1 -0.3" rpy="0 0 0"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="100" velocity="2.0"/>\n  </joint>\n\n  \x3c!-- Sensors --\x3e\n  <link name="camera_link">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.03"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n  </link>\n\n  <joint name="camera_joint" type="fixed">\n    <parent link="head_link"/>\n    <child link="camera_link"/>\n    <origin xyz="0.1 0 0" rpy="0 0 0"/>\n  </joint>\n\n  \x3c!-- Gazebo plugins --\x3e\n  <gazebo>\n    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n      <robotNamespace>/humanoid</robotNamespace>\n    </plugin>\n  </gazebo>\n\n  \x3c!-- Camera sensor --\x3e\n  <gazebo reference="camera_link">\n    <sensor type="camera" name="head_camera">\n      <update_rate>30.0</update_rate>\n      <camera name="head">\n        <horizontal_fov>1.3962634</horizontal_fov>\n        <image>\n          <width>1920</width>\n          <height>1080</height>\n          <format>R8G8B8</format>\n        </image>\n        <clip>\n          <near>0.02</near>\n          <far>300</far>\n        </clip>\n      </camera>\n      <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n        <alwaysOn>true</alwaysOn>\n        <updateRate>0.0</updateRate>\n        <cameraName>humanoid/camera</cameraName>\n        <imageTopicName>image_raw</imageTopicName>\n        <cameraInfoTopicName>camera_info</cameraInfoTopicName>\n        <frameName>camera_link</frameName>\n      </plugin>\n    </sensor>\n  </gazebo>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"humanoid-control-system",children:"Humanoid Control System"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Twist\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\nimport math\n\nclass HumanoidController(Node):\n    def __init__(self):\n        super().__init__('humanoid_controller')\n        \n        # Publishers\n        self.joint_pub = self.create_publisher(Float64MultiArray, '/humanoid/joint_group_position_controller/command', 10)\n        self.cmd_vel_sub = self.create_subscription(Twist, '/cmd_vel', self.cmd_vel_callback, 10)\n        \n        # Joint names and current positions\n        self.joint_names = [\n            'neck_joint',\n            'left_shoulder_joint', 'right_shoulder_joint',\n            'left_elbow_joint', 'right_elbow_joint',\n            'left_hip_joint', 'right_hip_joint',\n            'left_knee_joint', 'right_knee_joint',\n            'left_ankle_joint', 'right_ankle_joint'\n        ]\n        \n        self.joint_positions = [0.0] * len(self.joint_names)\n        self.walking_phase = 0.0\n        self.walking_speed = 0.0\n        \n        # Control timer\n        self.timer = self.create_timer(0.02, self.control_loop)  # 50Hz\n        \n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands\"\"\"\n        self.walking_speed = msg.linear.x\n        \n    def control_loop(self):\n        \"\"\"Main control loop for humanoid\"\"\"\n        if abs(self.walking_speed) > 0.01:\n            self.generate_walking_gait()\n        else:\n            self.maintain_balance()\n        \n        # Publish joint commands\n        joint_cmd = Float64MultiArray()\n        joint_cmd.data = self.joint_positions\n        self.joint_pub.publish(joint_cmd)\n    \n    def generate_walking_gait(self):\n        \"\"\"Generate walking gait pattern\"\"\"\n        # Simple sinusoidal walking pattern\n        self.walking_phase += 0.1 * self.walking_speed\n        \n        # Hip joints (alternating)\n        left_hip_angle = 0.3 * math.sin(self.walking_phase)\n        right_hip_angle = -0.3 * math.sin(self.walking_phase)\n        \n        # Knee joints (always positive for walking)\n        left_knee_angle = max(0, 0.5 * math.sin(self.walking_phase))\n        right_knee_angle = max(0, -0.5 * math.sin(self.walking_phase))\n        \n        # Ankle joints (for balance)\n        left_ankle_angle = -0.1 * math.sin(self.walking_phase)\n        right_ankle_angle = 0.1 * math.sin(self.walking_phase)\n        \n        # Arm swing (opposite to legs)\n        left_shoulder_angle = -0.2 * math.sin(self.walking_phase)\n        right_shoulder_angle = 0.2 * math.sin(self.walking_phase)\n        \n        # Update joint positions\n        self.joint_positions[1] = left_shoulder_angle   # left_shoulder\n        self.joint_positions[2] = right_shoulder_angle  # right_shoulder\n        self.joint_positions[5] = left_hip_angle        # left_hip\n        self.joint_positions[6] = right_hip_angle       # right_hip\n        self.joint_positions[7] = left_knee_angle       # left_knee\n        self.joint_positions[8] = right_knee_angle      # right_knee\n        self.joint_positions[9] = left_ankle_angle      # left_ankle\n        self.joint_positions[10] = right_ankle_angle    # right_ankle\n    \n    def maintain_balance(self):\n        \"\"\"Maintain standing balance\"\"\"\n        # Reset to neutral standing position\n        for i in range(len(self.joint_positions)):\n            self.joint_positions[i] = 0.0\n\nclass HumanoidPerception(Node):\n    def __init__(self):\n        super().__init__('humanoid_perception')\n        \n        # Subscribers\n        self.image_sub = self.create_subscription(Image, '/humanoid/camera/image_raw', self.image_callback, 10)\n        self.joint_sub = self.create_subscription(JointState, '/joint_states', self.joint_callback, 10)\n        \n        # Publishers\n        self.object_pub = self.create_publisher(String, '/detected_objects', 10)\n        \n        # Computer vision\n        self.bridge = CvBridge()\n        \n    def image_callback(self, msg):\n        \"\"\"Process camera images\"\"\"\n        try:\n            cv_image = self.bridge.imgmsg_to_cv2(msg, \"bgr8\")\n            \n            # Object detection\n            objects = self.detect_objects(cv_image)\n            \n            # Publish detected objects\n            if objects:\n                object_msg = String()\n                object_msg.data = ', '.join(objects)\n                self.object_pub.publish(object_msg)\n                \n        except Exception as e:\n            self.get_logger().error(f'Image processing error: {e}')\n    \n    def detect_objects(self, image):\n        \"\"\"Simple object detection\"\"\"\n        # Implement object detection logic\n        # This could use YOLO, detectron2, or other models\n        return ['person', 'chair', 'table']  # Placeholder\n    \n    def joint_callback(self, msg):\n        \"\"\"Monitor joint states\"\"\"\n        # Check for joint limits, overheating, etc.\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    \n    # Start both nodes\n    controller = HumanoidController()\n    perception = HumanoidPerception()\n    \n    executor = rclpy.executors.MultiThreadedExecutor()\n    executor.add_node(controller)\n    executor.add_node(perception)\n    \n    try:\n        executor.spin()\n    finally:\n        executor.shutdown()\n        controller.destroy_node()\n        perception.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-behaviors",children:"Advanced Behaviors"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"class HumanoidBehaviors:\n    def __init__(self):\n        self.behaviors = {\n            'wave': self.wave_gesture,\n            'bow': self.bow_gesture,\n            'point': self.point_gesture,\n            'dance': self.dance_sequence\n        }\n    \n    def wave_gesture(self):\n        \"\"\"Perform waving gesture\"\"\"\n        sequence = [\n            {'right_shoulder_joint': 1.5, 'right_elbow_joint': -1.0},\n            {'right_shoulder_joint': 1.2, 'right_elbow_joint': -0.5},\n            {'right_shoulder_joint': 1.5, 'right_elbow_joint': -1.0},\n            {'right_shoulder_joint': 0.0, 'right_elbow_joint': 0.0}\n        ]\n        return sequence\n    \n    def bow_gesture(self):\n        \"\"\"Perform bowing gesture\"\"\"\n        sequence = [\n            {'neck_joint': 0.5, 'left_hip_joint': 0.3, 'right_hip_joint': 0.3},\n            {'neck_joint': 0.0, 'left_hip_joint': 0.0, 'right_hip_joint': 0.0}\n        ]\n        return sequence\n"})}),"\n",(0,t.jsx)(e.h2,{id:"hardware-deployment",children:"Hardware Deployment"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simulation"}),": Test in Gazebo before real hardware"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real Hardware"}),": Deploy on actual humanoid platforms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safety"}),": Implement joint limits and collision detection"]}),"\n"]})]})}function _(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},8453(n,e,i){i.d(e,{R:()=>l,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function l(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:l(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);